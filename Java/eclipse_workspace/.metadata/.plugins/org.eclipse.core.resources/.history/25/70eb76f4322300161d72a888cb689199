package Aufgabe_8;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

public class BinarySearchTree {
	private TreeNode root;
	private int nodeGeneratingCounter;

	/**
	 * default constructor, treeroot is null
	 */
	public BinarySearchTree() {
	}

	/**
	 * constructor that initializes the tree with a TreeNode
	 * 
	 * @param root
	 */
	public BinarySearchTree(final TreeNode root) {
		this.root = root;
	}

	/**
	 * @param data
	 *            integer value to look for in the tree
	 * @return a TreeNode or null if element with data does not exist
	 */
	public TreeNode search(final int data) {
		return findNodeWithData(root, data);
	}

	/**
	 * recursive method to find data in the tree
	 * 
	 * @param current
	 * @param data
	 * @return
	 */
	private TreeNode findNodeWithData(final TreeNode current, final int data) {
		if (current == null)
			return current;
		if (current.getData() == data) {
			return current;
		}
		if (current.getLeftChild() != null) {
			final TreeNode result = findNodeWithData(current.getLeftChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		if (current.getRightChild() != null) {
			final TreeNode result = findNodeWithData(current.getRightChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		return null;
	}

	public void insert(final int newData) {
		if (root == null) {
			root = new TreeNode(null, newData);
			return;
		}

		TreeNode curr = root;
		TreeNode prev = null;
		while (true) {
			if (curr == null) {
				curr = new TreeNode(prev, newData);
				if (newData <= prev.getData()) {
					prev.setLeftChild(curr, false);
				} else {
					prev.setRightChild(curr, false);
				}
				return;
			}

			if (curr.getData() > newData) {
				prev = curr;
				curr = curr.getLeftChild();
			} else {
				prev = curr;
				curr = curr.getRightChild();
			}
		}
	}

	/**
	 * generates unsorted Tree with a number a maximum of maxNodes Nodes
	 * 
	 * @param min
	 *            smallest number of randomrange (included)
	 * @param max
	 *            biggest number of randomrange (included)
	 * @param maxNodes
	 */
	public void generateRandomUnsortedTree(final int maxNodes, final int min, final int max) {
		final Random rand = new Random();
		if (maxNodes < 1) {
			throw new IllegalArgumentException("maxNodes must be bigger than zero");
		}
		nodeGeneratingCounter = 1;
		if (max - min <= 0) {
			root = new TreeNode(null, 2);
		} else {
			root = new TreeNode(null, min + rand.nextInt(max - min + 1));
		}
		generateNode(root, maxNodes, rand, min, max);
		System.out.println(nodeGeneratingCounter + " Nodes generiert");
	}

	public void generateRandomTree(final int maxNodes, final int min, final int max) {
		final Random rand = new Random();

		for (int i = 0; i < maxNodes; ++i) {
			insert(min + rand.nextInt(max - min + 1));
		}
	}

	/**
	 * generates recursively childnodes for a parentnode while maximum not
	 * reached or no children where generated
	 * 
	 * @param parent
	 * @param maxNodes
	 * @param rand
	 * @param min
	 * @param max
	 */
	private void generateNode(final TreeNode parent, final int maxNodes, final Random rand, final int min,
			final int max) {
		if (nodeGeneratingCounter >= maxNodes)
			return;
		final boolean leftHasElement = rand.nextBoolean();
		if (leftHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setLeftChild(new TreeNode(parent, min + rand.nextInt(max - min + 1)), false);
			generateNode(parent.getLeftChild(), maxNodes, rand, min, max);
		}
		final boolean rightHasElement = rand.nextBoolean();
		if (rightHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setRightChild(new TreeNode(parent, min + rand.nextInt(max - min + 1)), false);
			generateNode(parent.getRightChild(), maxNodes, rand, min, max);
		}
	}

	public void delete(final int data) {
		final TreeNode delNode = search(data);
		if (delNode == null) {
			throw new IllegalArgumentException("data not element of the tree");
		}
		delete(delNode);
	}

	public void delete(final TreeNode delNode) {
		if (delNode == null) {
			throw new IllegalArgumentException("delNode must not be null");
		}

		// 1. case: both children of delNode are null
		if (delNode.getLeftChild() == null && delNode.getRightChild() == null) {

			System.out.println("0 children");
			// is delNode the current root of the tree
			if (delNode == root) {
				root = null;
			} else {
				// the TreeNode has a parent
				updateChildrenOfChildrenParent(delNode, null);
			}
			// delNode has been removed for the tree
			return;
		}

		// 2. case: one child exists
		if (delNode.getLeftChild() == null ^ delNode.getRightChild() == null) {
			System.out.println("1 child");
			// is delNode the current root of the tree
			if (delNode == root) {
				if (delNode.getLeftChild() == null) {
					root = delNode.getRightChild();
				} else {
					root = delNode.getLeftChild();
				}
			} else {
				// the TreeNode has a parent
				if (delNode.getLeftChild() == null) {
					updateChildrenOfChildrenParent(delNode, delNode.getRightChild());
				} else {
					updateChildrenOfChildrenParent(delNode, delNode.getLeftChild());
				}
			}
			return;
		}

		// last case: two children exist
		System.out.println("2 children");
		TreeNode curr = delNode.getRightChild();
		while (curr.getLeftChild() != null) {
			curr = curr.getLeftChild();
		}
		// replace date with the smallest of the right partial tree
		delNode.setData(curr.getData());

		// delete the node the data was taken from
		updateChildrenOfChildrenParent(curr, curr.getRightChild());
	}

	private void updateChildrenOfChildrenParent(final TreeNode child, final TreeNode newChild) {
		if (child == null) {
			throw new IllegalArgumentException("child is null");
		}
		if (child.getParent() == null) {
			throw new IllegalArgumentException("child has no parent: parent is null");
		}

		if (child.getParent().getLeftChild() == child) {
			child.getParent().setLeftChild(newChild, false);
		} else {
			child.getParent().setRightChild(newChild, false);
		}
	}

	public void printElems() {
		printElems(root);
		System.out.println();
	}

	private void printElems(final TreeNode current) {
		if (current == null)
			return;
		System.out.print(current.getData() + "; ");
		printElems(current.getLeftChild());
		printElems(current.getRightChild());

	}

	public void generateInOrderWire() {
		if (root == null) {
			return;
		}

		final List<TreeNode> parents = new ArrayList<TreeNode>();

		TreeNode curr = root;
		final boolean start = true;
		int cnt = 0;
		do {
			System.out.println(Arrays.toString(parents.toArray()));
			// find the smallest one child on the left side
			while (curr != null && curr.getRightChild() != null) {
				System.out.println(curr.getData() + " - left child exists");
				parents.add(curr);
				System.out.println(Arrays.toString(parents.toArray()));
				curr = curr.getLeftChild();
			}
			if (curr != null)
				System.out.println(curr.getData() + " - current node");
			// was there no child found and there are also no right children
			if (curr == root && curr.getRightChild() == null) {
				System.out.println(curr.getData() + " - is root -> return");
				return;
			}
			// smallest child found
			// wire up the right sides until there is a child
			while (curr != null && curr.getRightChild() == null) {
				System.out.println(curr.getData() + " - right is null");
				parents.remove(curr.getParent());
				System.out.println(Arrays.toString(parents.toArray()));
				// no right children: wire to parent
				curr.setRightChild(curr.getParent(), true);
				// follow wire to parent
				System.out.println(curr.getData());
				curr = curr.getRightChild();
				System.out.println(curr.getData() + " - current node via wire reached");
				System.out.println(curr.getData());
			}
			// go to the right child
			if (curr != null) {
				curr = curr.getRightChild();
			}
			System.out.println(curr.getData() + " - gone to right child");

			if (curr.getLeftChild() == null && curr.getRightChild() == null && parents.size() > 0) {
				System.out.println(curr.getData() + " - no children");

				curr.setRightChild(parents.get(parents.size() - 1), true);
				parents.remove(parents.size() - 1);

				System.out.println(Arrays.toString(parents.toArray()));

				curr = curr.getRightChild();
				System.out.println(curr.getData() + " - gone to parent via new node");
				curr = curr.getRightChild();
				if (curr.getRightChild() != null) {
					curr = curr.getRightChild();
					System.out.println(curr.getData() + " - right child of parent");
				}

			}
			System.out.println("runs = " + ++cnt);
		} while (curr.getRightChild() != null);
	}

	public void printInOrder() {
		System.out.println("Augabe:");
		TreeNode current = root;
		TreeNode previous = null;
		do {
			while (current.getLeftChild() != null && !current.leftIsWire()) {
				current = current.getLeftChild();
			}
			System.out.println(current.getData());
			previous = current;
			current = current.getRightChild();
			while (previous.rightIsWire() && (current != null)) {

				System.out.println(current.getData());
				previous = current;
				current = current.getRightChild();
			}

		} while (current != null);
	}

}
