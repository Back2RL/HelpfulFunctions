package Aufgabe_8;

import java.util.Random;

public class BinarySearchTree {
	private TreeNode root;
	private int nodeGeneratingCounter;

	/**
	 * default constructor, treeroot is null
	 */
	public BinarySearchTree() {
	}

	/**
	 * constructor that initializes the tree with a TreeNode
	 * 
	 * @param root
	 */
	public BinarySearchTree(TreeNode root) {
		this.root = root;
	}

	/**
	 * @param data
	 *            integer value to look for in the tree
	 * @return a TreeNode or null if element with data does not exist
	 */
	public TreeNode search(int data) {
		return findNodeWithData(root, data);
	}

	/**
	 * recursive method to find data in the tree
	 * 
	 * @param current
	 * @param data
	 * @return
	 */
	private TreeNode findNodeWithData(TreeNode current, int data) {
		if (current == null)
			return current;
		if (current.getData() == data) {
			return current;
		}
		System.out.println(current.getData());
		if (current.getLeftChild() != null) {
			TreeNode result = findNodeWithData(current.getLeftChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		if (current.getRightChild() != null) {
			TreeNode result = findNodeWithData(current.getRightChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		return null;
	}

	/**
	 * generates unsorted Tree with a number a maximum of maxNodes Nodes
	 * 
	 * @param min smallest number of randomrange (included)
	 * @param max biggest number of randomrange (included)
	 * @param maxNodes
	 */
	public void generateRandomUnsortedTree(final int maxNodes, final int min, final int max) {
		final Random rand = new Random();
		if(maxNodes < 1){
			throw new IllegalArgumentException("maxNodes must be bigger than zero");
		}
		nodeGeneratingCounter = 1;
		root = new TreeNode(null, min + rand.nextInt(max - min));
		generateNode(root, maxNodes, rand, min, max);
		System.out.println(nodeGeneratingCounter + " Nodes generiert");
	}

	/**
	 * generates recursively childnodes for a parentnode while maximum not reached or no childs where generated
	 * @param parent
	 * @param maxNodes
	 * @param rand
	 * @param min
	 * @param max
	 */
	private void generateNode(final TreeNode parent, final int maxNodes, final Random rand, final int min,
			final int max) {
		if (nodeGeneratingCounter >= maxNodes)
			return;
		final boolean leftHasElement = rand.nextBoolean();
		if (leftHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setLeftChild(new TreeNode(parent, min + rand.nextInt(max - min)));
			generateNode(parent.getLeftChild(), maxNodes, rand, min, max);
		}
		final boolean rightHasElement = rand.nextBoolean();
		if (rightHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setRightChild(new TreeNode(parent, min + rand.nextInt(max - min)));
			generateNode(parent.getRightChild(), maxNodes, rand, min, max);
		}
	}
}
