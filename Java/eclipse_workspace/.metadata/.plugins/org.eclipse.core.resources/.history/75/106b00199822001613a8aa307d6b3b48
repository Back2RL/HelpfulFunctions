package Aufgabe_8;

import java.util.Random;

public class BinarySearchTree {
	private TreeNode root;
	private int nodeGeneratingCounter;

	/**
	 * default constructor, treeroot is null
	 */
	public BinarySearchTree() {
	}

	/**
	 * constructor that initializes the tree with a TreeNode
	 * 
	 * @param root
	 */
	public BinarySearchTree(final TreeNode root) {
		this.root = root;
	}

	/**
	 * @param data
	 *            integer value to look for in the tree
	 * @return a TreeNode or null if element with data does not exist
	 */
	public TreeNode search(final int data) {
		return findNodeWithData(root, data);
	}

	/**
	 * recursive method to find data in the tree
	 * 
	 * @param current
	 * @param data
	 * @return
	 */
	private TreeNode findNodeWithData(final TreeNode current, final int data) {
		if (current == null)
			return current;
		if (current.getData() == data) {
			return current;
		}
		System.out.println(current.getData());
		if (current.getLeftChild() != null) {
			TreeNode result = findNodeWithData(current.getLeftChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		if (current.getRightChild() != null) {
			TreeNode result = findNodeWithData(current.getRightChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		return null;
	}

	/**
	 * generates unsorted Tree with a number a maximum of maxNodes Nodes
	 * 
	 * @param min
	 *            smallest number of randomrange (included)
	 * @param max
	 *            biggest number of randomrange (included)
	 * @param maxNodes
	 */
	public void generateRandomUnsortedTree(final int maxNodes, final int min, final int max) {
		final Random rand = new Random();
		if (maxNodes < 1) {
			throw new IllegalArgumentException("maxNodes must be bigger than zero");
		}
		nodeGeneratingCounter = 1;
		root = new TreeNode(null, min + rand.nextInt(max - min));
		generateNode(root, maxNodes, rand, min, max);
		System.out.println(nodeGeneratingCounter + " Nodes generiert");
	}

	/**
	 * generates recursively childnodes for a parentnode while maximum not
	 * reached or no children where generated
	 * 
	 * @param parent
	 * @param maxNodes
	 * @param rand
	 * @param min
	 * @param max
	 */
	private void generateNode(final TreeNode parent, final int maxNodes, final Random rand, final int min,
			final int max) {
		if (nodeGeneratingCounter >= maxNodes)
			return;
		final boolean leftHasElement = rand.nextBoolean();
		if (leftHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setLeftChild(new TreeNode(parent, min + rand.nextInt(max - min)));
			generateNode(parent.getLeftChild(), maxNodes, rand, min, max);
		}
		final boolean rightHasElement = rand.nextBoolean();
		if (rightHasElement && nodeGeneratingCounter < maxNodes) {
			nodeGeneratingCounter++;
			parent.setRightChild(new TreeNode(parent, min + rand.nextInt(max - min)));
			generateNode(parent.getRightChild(), maxNodes, rand, min, max);
		}
	}

	public void delete(int data) {
		delete(search(data));
	}

	public void delete(final TreeNode delNode) {
		if (delNode == null) {
			throw new IllegalArgumentException("delNode must not be null");
		}

		// 1. case: both children of delNode are null
		if (delNode.getLeftChild() == null && delNode.getRightChild() == null) {
			// is delNode the current root of the tree
			if (delNode.getParent() == null) {
				root = null;
			} else {
				// the TreeNode has a parent
				updateChildrenOfChildrenParent(delNode, null);
			}
			// delNode has been removed for the tree
			return;
		}

		// 2. case: one child exists
		if (delNode.getLeftChild() == null ^ delNode.getRightChild() == null) {
			// is delNode the current root of the tree
			if (delNode.getParent() == null) {
				root = null;
			} else {
				// the TreeNode has a parent
				if (delNode.getLeftChild() == null) {
					updateChildrenOfChildrenParent(delNode, delNode.getRightChild());
				} else {
					updateChildrenOfChildrenParent(delNode, delNode.getLeftChild());
				}
			}
			return;
		}

		// last case: two children exist
		TreeNode curr = delNode.getRightChild();
		while (curr.getLeftChild() != null) {
			curr = curr.getLeftChild();
		}
		// replace date with the smallest of the right partial tree
		delNode.setData(curr.getData());
		// delete the node the data was taken from
		updateChildrenOfChildrenParent(curr, curr.getRightChild());
	}

	private void updateChildrenOfChildrenParent(final TreeNode child, final TreeNode newChild) {
		if (child.getParent().getLeftChild().equals(child)) {
			child.getParent().setLeftChild(newChild);
		} else {
			child.getParent().setRightChild(newChild);
		}
	}

	public TreeNode printElems(final int data) {
printElems(root, data);	
	}
	}
	private TreeNode printElems(final TreeNode current, final int data) {
		if (current == null)
			return current;
		System.out.println(current.getData());
		if (current.getLeftChild() != null) {
			TreeNode result = printElems(current.getLeftChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		if (current.getRightChild() != null) {
			TreeNode result = printElems(current.getRightChild(), data);
			if (result != null && result.getData() == data) {
				return result;
			}
		}
		return null;
	}

}
