/*
9.1a
-gleiche Spaltenanzahl,
-Spaltentypen müssen zusammenpassen,
-Einträge der Datentypen müssen gleich sein (z.B. Varchar(x), Umwandlungen erfolgen nicht)

--9.1b
--Vereinigung ohne Duplikate:
select *
from xyz
union
select * 
from abc;

--Vereinigung mit Duplikaten:
select *
from xyz
union all
select * 
from abc;

--Schnittmenge (s.o. intersect all):
select *
from xyz
intersect
select * 
from abc;

--Differenzmenge:
select *
from xyz
except
select * 
from abc;

--Differenmenge mit Elementanzahl:
select *
from xyz
except all
select * 
from abc;

--9.1c
--Teilanfragen im where-Ausdruck
select name, alter
from menschen
where alter = (select max(menschen.name)
from meschen);
 
--9.1d
where x > all (select ...) --> die wählen die größer als alle Elemente aus dem 2. ausdruck sind
where x > any (select ...) --> die wählen die größer als irgend ein Element aus dem 2. ausdruck sind


--9.1e
join ist das gleiche wie die Bildung eines kartesischen produkt von relationen mit dem anschließenden Entfernen der Duplikate
join: nur zeilen in denen in beiden tabellen einträge existieren werden ausgegeben
left join: alle elemente der 1. tabelle werden ausgegeben, leere zeilen in der 2. werden mit null
 aufgefüllt
right join: wie left join, 1. wird ggf. mit null aufgefüllt
full join: beide tabellen werden ggf. mit null-zeilen aufgefüllt, alles wird ausgegeben
natural joins: doppelte spalten (mit gleichem namen) werden nicht mehr ausgegeben,
natural left/right/full join: s.o. 

*/

--9.2.a
-- unterabfrage im select
(select loc.country_id land, round(avg(emp.salary)) avggehalt 
from HR.EMPLOYEES emp, HR.DEPARTMENTS dep, HR.LOCATIONS loc
where emp.DEPARTMENT_ID = dep.DEPARTMENT_ID
and dep.LOCATION_ID = loc.LOCATION_ID
group by loc.COUNTRY_ID);

select aemp.employee_id,aemp.salary
from HR.EMPLOYEES aemp, HR.DEPARTMENTS adep, HR.LOCATIONS aloc,

(select avg(emp.salary) avgs, loc.country_id land
from HR.EMPLOYEES emp, HR.DEPARTMENTS dep, HR.LOCATIONS loc
where emp.DEPARTMENT_ID = dep.DEPARTMENT_ID
and dep.LOCATION_ID = loc.LOCATION_ID
group by loc.COUNTRY_ID) innen

where aemp.DEPARTMENT_ID = adep.DEPARTMENT_ID
and adep.LOCATION_ID = aloc.LOCATION_ID 
and aemp.salary > innen.avgs
and aloc.COUNTRY_ID = innen.land;

-- mit joins
select aemp.employee_id,aemp.salary
from HR.EMPLOYEES aemp 
join HR.DEPARTMENTS adep on aemp.DEPARTMENT_ID = adep.DEPARTMENT_ID 
join HR.LOCATIONS aloc on adep.LOCATION_ID = aloc.LOCATION_ID 
join (select avg(emp.salary) avgs, loc.country_id land
from HR.EMPLOYEES emp, HR.DEPARTMENTS dep, HR.LOCATIONS loc
where emp.DEPARTMENT_ID = dep.DEPARTMENT_ID
and dep.LOCATION_ID = loc.LOCATION_ID
group by loc.COUNTRY_ID) innen on aloc.COUNTRY_ID = innen.land

where aemp.salary > innen.avgs;

-- 9.




